{"id":874160089,"lang":"cpp","lang_name":"C++","time":"8 months, 2 weeks","timestamp":1673194447,"status":10,"status_display":"Accepted","runtime":"7 ms","url":"/submissions/detail/874160089/","is_pending":"Not Pending","title":"Reverse Nodes in k-Group","memory":"11.5 MB","code":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        ListNode* dummy = new ListNode(0);\n        dummy->next = head;\n        ListNode* pointer = dummy;\n        while (pointer != NULL) {\n            ListNode* temp = pointer;\n            // Firstly we check whether there are k nodes available or not\n            for (int i = 0; (i < k) && (temp != NULL); i++) {\n                temp = temp->next;\n            }\n            if (temp == NULL) {\n                break;\n            }\n            \n            ListNode* prev = NULL;\n            ListNode* curr = pointer->next;\n            ListNode* next = NULL;\n            \n            for (int i = 0; i < k; i++) {\n                next = curr->next;\n                curr->next = prev;\n                prev = curr;\n                curr = next;\n            }\n            \n            // 0 (pointer) -> 1 <- 2 <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\n            // idea is to link the pointer to 3 and link 1 to 4:    \n            \n            ListNode* tail = pointer->next;\n            tail->next = curr;\n            pointer->next = prev;\n            pointer = tail;\n        }\n        return dummy->next;\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111","title_slug":"reverse-nodes-in-k-group","has_notes":false,"flag_type":1}