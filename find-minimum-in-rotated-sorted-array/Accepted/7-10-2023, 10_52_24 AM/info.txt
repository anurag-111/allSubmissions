{"id":990679964,"lang":"cpp","lang_name":"C++","time":"2 months, 1 week","timestamp":1688966544,"status":10,"status_display":"Accepted","runtime":"10 ms","url":"/submissions/detail/990679964/","is_pending":"Not Pending","title":"Find Minimum in Rotated Sorted Array","memory":"10.1 MB","code":"class Solution {\npublic:\n    /**\n     * Find the minimum element in a rotated sorted array.\n     *\n     * @param nums The rotated sorted array.\n     * @return The minimum element.\n     */\n    int findMin(vector<int>& nums) {\n        int low = 0;                              // Leftmost index of the search range\n        int high = nums.size() - 1;               // Rightmost index of the search range\n\n        while (low < high) {\n            int mid = low + (high - low) / 2;      // Calculate the middle index\n\n            if (nums[mid] > nums[high]) {\n                // Minimum element is in the right part of the array\n                low = mid + 1;                     // Adjust the low pointer\n            } else {\n                // Minimum element is in the left part of the array or at the middle element\n                high = mid;                        // Adjust the high pointer\n            }\n        }\n\n        return nums[low];                          // Return the element at the low index as the minimum\n    }\n};\n\n\n/*\n\nTime Complexity: O(log N)\n\nThe search is performed using binary search, which reduces the search space by half in each iteration. Hence, the time complexity is logarithmic, O(log N), where N is the number of elements in the input array.\n\nSpace Complexity: O(1)\n\nThe algorithm uses a constant amount of extra space for the variables low, high, and mid. Therefore, the space complexity is O(1), indicating constant space usage regardless of the input size.\n\n--------------------------------------------------------------------------------------------------------\n\nSince we always round down for mid, right would never be the same as mid. \nThis situation becomes very clear in the case of a two element array \n(or just in general when the left and right pointers are adjacent. I.e., \nfor an input [5,1]. We have l=0,m=0,r=1, due to our rounding down (floor division). \nIf we didn't use floor division, with this input, we could end up with l=0,m=1,r=1, \nso m and r are pointing at the same one. This causes several problems. \nIt breaks our loop invariant that m and r are never the same. And because \nit breaks this invariant, it causes us to enter an infinite loop. Since we don't \nhandle equals with our code, so we're just stuck here eternally.\n\n\n*/","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"find-minimum-in-rotated-sorted-array","has_notes":false,"flag_type":1}