{"id":973561646,"lang":"cpp","lang_name":"C++","time":"3Â months","timestamp":1687032578,"status":10,"status_display":"Accepted","runtime":"196 ms","url":"/submissions/detail/973561646/","is_pending":"Not Pending","title":"Make Array Strictly Increasing","memory":"42.8 MB","code":"class Solution {\npublic:\n    int solve(int i, int j, int& len1, int& len2, int prev, vector<vector<int>>& dp, vector<int>& nums1, vector<int>& nums2) {\n        if (i == len1) {\n            return 0; // Reached the end of nums1, return 0 as no more elements to consider\n        }\n\n        // Find the next valid index in nums2 using binary search\n        j = upper_bound(nums2.begin() + j, nums2.end(), prev) - nums2.begin();\n\n        if (dp[i][j] != -1)\n            return dp[i][j]; // If the subproblem has already been solved, return the precomputed result\n\n        if (j == len2 && nums1[i] <= prev)\n            return 2001; // If reached the end of nums2 and nums1[i] is not greater than prev, return an arbitrary large value (indicating not possible)\n\n        int take = 2001, notTake = 2001;\n        if (j != len2)\n            take = solve(i + 1, j + 1, len1, len2, nums2[j], dp, nums1, nums2) + 1; // Try taking the element from nums2 and move to the next indices\n\n        if (nums1[i] > prev)\n            notTake = solve(i + 1, j, len1, len2, nums1[i], dp, nums1, nums2); // Skip nums1[i] and move to the next index\n\n        return dp[i][j] = min(take, notTake); // Store the result in dp table and return the minimum of take and notTake\n    }\n\n    int makeArrayIncreasing(vector<int>& nums1, vector<int>& nums2) {\n        int len1 = nums1.size();\n        int len2 = nums2.size();\n        vector<vector<int>> dp(len1 + 1, vector<int>(len2 + 1, -1)); // dp table to store intermediate results\n\n        sort(nums2.begin(), nums2.end()); // Sort nums2 in ascending order for binary search\n\n        int result = solve(0, 0, len1, len2, -1, dp, nums1, nums2); // Call the recursive solve function\n        if (result > len1)\n            return -1; // If the result is greater than the length of nums1, it means it's not possible to make nums1 strictly increasing\n\n        return result; // Return the minimum number of operations required to make nums1 strictly increasing\n    }\n};\n","compare_result":"111111111111111111111","title_slug":"make-array-strictly-increasing","has_notes":false,"flag_type":1}