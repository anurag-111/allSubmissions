{"id":1022324842,"lang":"cpp","lang_name":"C++","time":"1Â month","timestamp":1692123040,"status":10,"status_display":"Accepted","runtime":"132 ms","url":"/submissions/detail/1022324842/","is_pending":"Not Pending","title":"Amount of Time for Binary Tree to Be Infected","memory":"117.2 MB","code":"class Solution {\npublic:\n    //res to store maximum distance from the first infected node\n    int res = 0;\n    pair<bool,int> dfs(TreeNode* root, int start){\n        if(!root) return {false,0};\n        //return type pair states whether we came across start or not and maximum distance in this call\n        pair<bool,int>p1 = dfs(root->left,start);\n        pair<bool,int>p2 = dfs(root->right,start);\n        // if we find the node then the maximum distance for now will be the maximum of 2 dfs calls and we will send the current distance as 0 to its parent(if exists)\n        if(root->val==start){\n            int temp = max(p2.second,p1.second);\n            res = max(res,temp);\n            return {true,0};\n        }\n        //if we find the start node to any of the dfs calls then the answer will be maximum of its previous value or sum of distance of start from this node and other path\n        if(p1.first){\n            int sum = p1.second+p2.second+1;\n            res = max(res,sum);\n            return {true,p1.second+1};\n        }else if(p2.first){\n            int sum = p1.second+p2.second+1;\n            res = max(res,sum);\n            return {true,p2.second+1};\n        }\n        //If we are still here, it means we have not come across the start node in this dfs call and hence will retuen maximum of 2 dfs calls\n        int sum = max(p1.second,p2.second);\n        return {false,1+sum};\n    }\n    \n    int amountOfTime(TreeNode* root, int start) {\n        dfs(root,start);\n        return res;\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"amount-of-time-for-binary-tree-to-be-infected","has_notes":false,"flag_type":1}