{"id":1023899818,"lang":"cpp","lang_name":"C++","time":"1Â month","timestamp":1692273186,"status":10,"status_display":"Accepted","runtime":"269 ms","url":"/submissions/detail/1023899818/","is_pending":"Not Pending","title":"Amount of Time for Binary Tree to Be Infected","memory":"148.2 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n \nclass Solution {\n\tprivate :\n\t\tTreeNode *childToParentMapper(TreeNode *root, unordered_map<TreeNode*, TreeNode*> &childToParentMap, int target) {\n\t\t\t// Queue for BFS traversal\n\t\t\tqueue<TreeNode*> nodes;\n\t\t\tnodes.push(root);\n\t\t\t\n\t\t\tTreeNode *targetNode = nullptr;\n\t\t\t\n\t\t\twhile(!nodes.empty()) {\n\t\t\t\tint size = nodes.size();\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < size; i++) {\n\t\t\t\t\tTreeNode* current = nodes.front();\n\t\t\t\t\tnodes.pop();\n\t\t\t\t\t\n\t\t\t\t\tif(current -> val == target) {\n\t\t\t\t\ttargetNode = current;\n\t\t\t\t  }\n\t\t\t\t\t\n\t\t\t\t\tif(current -> left) {\n\t\t\t\t\t\tnodes.push(current -> left);\n\t\t\t\t\t\tchildToParentMap[current -> left] = current;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(current -> right) {\n\t\t\t\t\t\tnodes.push(current -> right);\n\t\t\t\t\t\tchildToParentMap[current -> right] = current;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn targetNode;\n\t\t}\n\t\t\n\tpublic :\n\t\tint amountOfTime(TreeNode* root, int target) {\n\t\t\t// Mapping Creation\n\t\t\tunordered_map<TreeNode*, TreeNode*> childToParentMap;\n\t\t\t\n\t\t\t// Target value has been given to us in 'int', convert to 'TreeNode*'\n\t\t\t// Function call for mapping\n\t\t\tTreeNode *targetNode = childToParentMapper(root, childToParentMap, target);\n\t\t\t\n\t\t\t//  For visited markings\n\t\t\tunordered_set<TreeNode*> visited;\n\t\t\t\n\t\t\t// Queue for BFS\n\t\t\tqueue<TreeNode*> nodes;\n\t\t\tnodes.push(targetNode);\n\t\t\t\n\t\t\t// Insert the visited node\n\t\t\tvisited.insert(targetNode);\n\t\t\t\n\t\t\t// Time to burn : Initialize with -1 to account for starting from target\n\t\t\tint timeToBurn = -1;\n\t\t\t\n\t\t\twhile(!nodes.empty()) {\n\t\t\t\tint size = nodes.size();\n\t\t\t\t\n\t\t\t\t// Level order traversal\n\t\t\t\tfor(int i = 0; i < size; i++) {\n\t\t\t\t\tTreeNode* current = nodes.front();\n\t\t\t\t\tnodes.pop();\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t// Left residing nodes\n\t\t\t\t\tif(current -> left && visited.find(current -> left) == visited.end()) {\n\t\t\t\t\t\tvisited.insert(current -> left);\n\t\t\t\t\t\tnodes.push(current -> left);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Right residing nodes\n\t\t\t\t\tif(current -> right && visited.find(current -> right) == visited.end()) {\n\t\t\t\t\t\tvisited.insert(current -> right);\n\t\t\t\t\t\tnodes.push(current -> right);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// For parents of the current node\n\t\t\t\t\tif(childToParentMap[current] && visited.find(childToParentMap[current]) == visited.end()) {\n\t\t\t\t\t\tvisited.insert(childToParentMap[current]);\n\t\t\t\t\t\tnodes.push(childToParentMap[current]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttimeToBurn++;\n\t\t\t\t\n \t\t\t}\n\t\t\t\n\t\t\treturn timeToBurn;\n\t\t}\n};\n\n//  time complexity of O(N) and a space complexity of O(N)","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"amount-of-time-for-binary-tree-to-be-infected","has_notes":false,"flag_type":1}