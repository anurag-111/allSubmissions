{"id":909612847,"lang":"cpp","lang_name":"C++","time":"6 months, 2 weeks","timestamp":1678030006,"status":10,"status_display":"Accepted","runtime":"3 ms","url":"/submissions/detail/909612847/","is_pending":"Not Pending","title":"Rotting Oranges","memory":"13 MB","code":"class Solution {\n  public:\n    \n    int orangesRotting(vector<vector<int>>& grid) {\n      \n      int n = grid.size();\n      int m = grid[0].size();\n\n      // store {{row, column}, time}\n      queue <pair<pair<int, int>, int >> q;\n      int vis[n][m];\n      int cntFresh = 0;\n      for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n          // if cell contains rotten orange\n          if (grid[i][j] == 2) {\n            q.push({{i, j}, 0}); \n            // mark as visited (rotten) in visited array\n            vis[i][j] = 2;\n          }\n          // if not rotten\n          else {\n            vis[i][j] = 0;\n          }\n          // count fresh oranges\n          if (grid[i][j] == 1) cntFresh++;\n        }\n      }\n\n      int tm = 0;\n      // delta row and delta column\n      int drow[] = {-1, 0, +1, 0};\n      int dcol[] = {0, 1, 0, -1}; \n      int cnt = 0;\n\n      // bfs traversal (until the queue becomes empty)\n      while (!q.empty()) {\n        int r = q.front().first.first;\n        int c = q.front().first.second;\n        int t = q.front().second;\n        tm = max(tm, t);\n        q.pop();\n        // exactly 4 neighbours \n        for (int i = 0; i < 4; i++) {\n          // neighbouring row and column\n          int nrow = r + drow[i];\n          int ncol = c + dcol[i];\n          // check for valid cell and \n          // then for unvisited fresh orange\n          if (nrow >= 0 && nrow < n && ncol >= 0 && ncol < m &&\n            vis[nrow][ncol] == 0 && grid[nrow][ncol] == 1) {\n            // push in queue with timer increased\n             q.push({{nrow, ncol}, t + 1}); \n            // mark as rotten\n            vis[nrow][ncol] = 2;\n            cnt++;\n          }\n        }\n      }\n\n      // if all oranges are not rotten\n      if (cnt != cntFresh) return -1;\n\n      return tm;\n\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"rotting-oranges","has_notes":false,"flag_type":1}