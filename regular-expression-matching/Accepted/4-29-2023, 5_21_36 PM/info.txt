{"id":941518617,"lang":"cpp","lang_name":"C++","time":"4 months, 3 weeks","timestamp":1682769096,"status":10,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/941518617/","is_pending":"Not Pending","title":"Regular Expression Matching","memory":"6.9 MB","code":"class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        \n        // Create a 2D boolean vector with p.size() + 1 rows and s.size() + 1 columns,\n        // and initialize all elements to false.\n        vector<vector<bool>> dp(p.size() + 1, vector<bool> (s.size() + 1, false));\n        \n        // Loop through all elements of the dp vector.\n        for(int i = 0; i < dp.size(); i++) {\n            for(int j = 0; j < dp[0].size(); j++) {\n                \n                // This condition checks if both the string and pattern are empty, \n                // which means they match by default, so dp[i][j] is set to true.\n                if(i == 0 && j == 0) {\n                    dp[i][j] = true;\n                } \n                \n                // This condition checks if the pattern is empty but the string is not. \n                // In this case, there cannot be a match between the string and pattern, \n                // so dp[i][j] is set to false.\n                else if(i == 0) {\n                    dp[i][j] = false;\n                } \n                \n                // This condition checks if the string is empty but the pattern is not.  \n                else if(j == 0) {\n                    // In this case, the only way there can be a match is if the pattern \n                    // consists entirely of * characters, which can match an empty string. \n                    // The code checks the character immediately before the * in the pattern (i.e., p[i - 1]).\n                    char patternCharacter = p[i - 1];\n                    \n                    // If the character is '*', set dp[i][j] to the value of dp[i-2][j].\n                    // i.e., sets dp[i][j] based on whether the pattern before that (i.e., p[i - 2]) \n                    // can match an empty string.\n                    if(patternCharacter == '*') {\n                        dp[i][j] = dp[i - 2][j];\n                    } \n                    \n                    // Otherwise, set dp[i][j] to false.\n                    else {\n                        dp[i][j] = false;\n                    }\n                } \n                \n                // This condition covers the main logic of the algorithm. \n                // It checks the current character in both the string (s[i-1]) \n                // and pattern (p[i-1]) and sets dp[i][j] based on whether there is a match.\n                else {\n                    char patternCharacter = p[i - 1];\n                    char stringCharacter = s[j - 1];                      \n                    if(patternCharacter == '*') {\n                        // If the pattern character is *, then there are two possibilities: \n                        // either the * matches zero occurrences of the preceding character, \n                        // in which case dp[i][j] is set to dp[i-2][j].\n                        dp[i][j] = dp[i - 2][j];\n                        \n                        // OR\n\n                        // The * matches one or more occurrences of the preceding character, \n                        // in which case dp[i][j] is set to dp[i][j-1] or dp[i-1][j-1] \n                        // depending on whether the preceding character matches the current character in the string.\n                        char patternSecondLastCharacter = p[i - 2];\n                        if(patternSecondLastCharacter == '.' || patternSecondLastCharacter == stringCharacter) {\n                            dp[i][j] = dp[i][j - 1] || dp[i][j];\n                        }     \n                    } \n                    \n                    // If the pattern character is ., then it matches any character in the string, \n                    // so dp[i][j] is set to dp[i-1][j-1]..\n                    else if(patternCharacter == '.'){\n                        dp[i][j] = dp[i - 1][j - 1];\n                    } \n                    \n                    // If the pattern character is not * or ., then it must match the \n                    // corresponding character in the string for there to be a match, \n                    // so dp[i][j] is set to dp[i-1][j-1] if the characters.\n                    else if(patternCharacter == stringCharacter) {\n                        dp[i][j] = dp[i - 1][j - 1];\n                    } \n                    \n                    // If none of the above conditions are met, set dp[i][j] to false.\n                    else {\n                        dp[i][j] = false;\n                    }\n\n                }\n            }\n        }\n        \n        // Return the value of dp[p.size][s.size]\n        return dp[p.size()][s.size()];\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"regular-expression-matching","has_notes":false,"flag_type":1}