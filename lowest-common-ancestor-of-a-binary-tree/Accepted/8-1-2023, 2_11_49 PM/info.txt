{"id":1009212867,"lang":"cpp","lang_name":"C++","time":"1 month, 3 weeks","timestamp":1690879309,"status":10,"status_display":"Accepted","runtime":"10 ms","url":"/submissions/detail/1009212867/","is_pending":"Not Pending","title":"Lowest Common Ancestor of a Binary Tree","memory":"14.4 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        // Base case: If the root is NULL or one of the nodes is the root, return the root itself (or NULL).\n        if (root == nullptr || root == p || root == q) {\n            return root;\n        }\n\n        // Recursively find the LCA in the left and right subtrees.\n        TreeNode* leftLCA = lowestCommonAncestor(root->left, p, q);\n        TreeNode* rightLCA = lowestCommonAncestor(root->right, p, q);\n\n        // Result:\n        // If one of the subtrees returns NULL, it means that both nodes are in the other subtree,\n        // so we return the non-NULL result (the LCA found in the other subtree).\n        if (leftLCA == nullptr) {\n            return rightLCA;\n        } else if (rightLCA == nullptr) {\n            return leftLCA;\n        }\n        // If both left and right subtrees return non-NULL results, it means that each node is present\n        // in one of the subtrees, so the current root node is the LCA.\n        return root;\n    }\n};\n\n/*\nTime Complexity: The time complexity of the lowestCommonAncestor function is O(n), \nwhere \"n\" is the number of nodes in the binary tree. In the worst case, \nthe algorithm may have to visit all nodes in the tree to find the lowest common ancestor.\n\nSpace Complexity: The space complexity of the lowestCommonAncestor function is O(n),\nin the worst-case scenario, the binary tree can be highly unbalanced, with each node having only one child, \nleading to a linear chain of nodes from the root to a leaf. In this case, the height of the binary tree \nis equal to the number of nodes, which is \"n.\" Therefore, the space complexity becomes O(n) because \nthe recursion can go as deep as the number of nodes in the tree.\n*/","compare_result":"1111111111111111111111111111111","title_slug":"lowest-common-ancestor-of-a-binary-tree","has_notes":false,"flag_type":1}