{"id":895187728,"lang":"cpp","lang_name":"C++","time":"7 months, 1 week","timestamp":1676012844,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/895187728/","is_pending":"Not Pending","title":"As Far from Land as Possible","memory":"N/A","code":"class Solution {\nprivate:\n    void helper(vector<vector<int>>& grid, int i, int j, int dist = 1) {\n        if (i < 0 || j < 0 || i >= grid.size() || j >= grid[i].size() || (grid[i][j] != 0 && grid[i][j] <= dist)) { \n            return;\n        }\n        grid[i][j] = dist;\n        helper(grid, i - 1, j, dist + 1), helper(grid, i + 1, j, dist + 1), helper(grid, i, j - 1, dist + 1), helper(grid, i, j + 1, dist + 1);\n}\n\npublic:\n    int maxDistance(vector<vector<int>>& grid, int mx = -1) {\n        if(!grid.size()) {\n            return 0;\n        }\n        \n        for(int i = 0; i < grid.size(); i++) {\n            for(int j = 0; j < grid[i].size(); j++) {\n                if (grid[i][j] == 1) {\n                    grid[i][j] = 0;\n                    helper(grid, i, j);\n                }\n            }\n        }\n\n        for(int i = 0; i < grid.size(); i++) {\n            for(int j = 0; j < grid[i].size(); j++) {\n                if (grid[i][j] > 1) {\n                    mx = max(mx, grid[i][j] - 1);\n                }\n            }\n        }\n        return mx;\n    }\n};\n\n\n// Approach :\n// For each 'land' cell, start DFS and record the distance in 'water' cells.\n\n// If the distance in the 'water' cell is smaller than the current distance, we stop there. Otherwise, we update the distance to the smaller value and keep going.\n\n// Complexity :\n// Runtime: O(m * n * n), where m is the number of land cells.\n// Memory: O(n * n) for the recursion.","compare_result":"1111111111111111111111111111111111110","title_slug":"as-far-from-land-as-possible","has_notes":false,"flag_type":1}