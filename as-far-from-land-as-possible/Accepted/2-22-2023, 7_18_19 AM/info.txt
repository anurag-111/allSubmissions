{"id":902619572,"lang":"cpp","lang_name":"C++","time":"7Â months","timestamp":1677030499,"status":10,"status_display":"Accepted","runtime":"71 ms","url":"/submissions/detail/902619572/","is_pending":"Not Pending","title":"As Far from Land as Possible","memory":"19.9 MB","code":"class Solution {\npublic:\n    int maxDistance(vector<vector<int>>& grid) {\n        \n        int n = grid.size();\n        int dist = 0, size;\n        \n        // Create a queue to store the cells to be processed\n        queue<pair<int, int>> q;\n        \n        // Array to store the row and column shifts for the four directions\n        int drow[] = {0, -1, 0, 1}, dcol[] = {-1, 0, 1, 0};\n        \n        // Start the BFS from all the cells that have the value 1\n        for(int i = 0; i < n; i++) \n            for(int j = 0; j < n; j++) {   \n                if(grid[i][j] == 1)\n                    q.push({i, j});\n            }\n\n        // If all cells are 1's, return -1\n        if(q.size() == n*n) {\n            return -1;\n        }\n    \n        // Continue the BFS until all cells have been processed\n        while(!q.empty()){\n\n            // Get the number of cells to be processed in this round\n            size = q.size();\n            \n            // Increase the distance\n            dist++;\n            \n            // Process all the cells in the current round\n            while(size--){\n                // Get the row and column of the current cell\n                int row = q.front().first;\n                int col = q.front().second;\n                \n                // Remove the current cell from the queue\n                q.pop();\n                \n                // Process all the four directions\n                for(int i=0; i < 4; i++){\n                    \n                    // Get the row and column of the next cell\n                    int nrow = row + drow[i];\n                    int ncol = col + dcol[i];\n                    \n                    // Check if the next cell is within the grid and has a value 0\n                    if(nrow >= 0 && ncol >= 0 && nrow < n && ncol < n && grid[nrow][ncol] == 0){\n                        // Update the value of the next cell\n                        grid[nrow][ncol] = 1;\n                        \n                        // Add the next cell to the queue for the next round\n                        q.push({nrow, ncol});\n                    } \n                }\n            }\n        }\n        \n        // Return the final distance\n        return dist - 1;\n    }\n};\n\n// Approach : BFS\n// Time complexity: O(n * n)\n// Space complexity: O(n * n)\n","compare_result":"11111111111111111111111111111111111111","title_slug":"as-far-from-land-as-possible","has_notes":false,"flag_type":1}