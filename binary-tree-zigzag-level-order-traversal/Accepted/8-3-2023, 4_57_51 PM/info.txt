{"id":1011111446,"lang":"cpp","lang_name":"C++","time":"1 month, 2 weeks","timestamp":1691062071,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1011111446/","is_pending":"Not Pending","title":"Binary Tree Zigzag Level Order Traversal","memory":"12.1 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\nprivate:\n    vector<vector<int>> result;\n\n    // Helper function to perform zigzag level order traversal\n    void zigzagTraversal(TreeNode* root) {\n        // Check if the root is null\n        if (root == NULL) {\n            return;\n        }\n\n        // Create a queue for level-order traversal\n        queue<TreeNode*> q;\n        q.push(root);\n\n        // Variable to track the direction of traversal (left to right or right to left)\n        bool leftToRight = true;\n\n        while (!q.empty()) {\n            // Get the current level size\n            int levelSize = q.size();\n\n            // Vector to store the values of the current level\n            vector<int> currentLevel;\n\n            // Process nodes in the current level\n            for (int i = 0; i < levelSize; i++) {\n                TreeNode* node = q.front();\n                q.pop();\n\n                // Add node values in the current level based on the direction of traversal\n                if (leftToRight) {\n                    currentLevel.push_back(node->val); // Add node values from left to right\n                } else {\n                    currentLevel.insert(currentLevel.begin(), node->val); // Add node values from right to left\n                }\n\n                // Add the children of the current node to the queue for the next level traversal\n                if (node->left) {\n                    q.push(node->left);\n                }\n\n                if (node->right) {\n                    q.push(node->right);\n                }\n            }\n\n            // Toggle the direction for the next level traversal\n            leftToRight = !leftToRight;\n\n            // Store the values of the current level in the result\n            result.push_back(currentLevel);\n        }\n    }\n\npublic:\n    // Function to perform zigzag level order traversal\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n        // Call the helper function for zigzag traversal\n        zigzagTraversal(root);\n\n        // Return the final result\n        return result;\n    }\n};\n\n/* \n\ncurrentLevel.insert(currentLevel.begin(), node->val); inserts the value node->val \nat the beginning of the currentLevel vector. This effectively reverses the order of \nelements in the vector, pushing new nodes to the front of the vector as they are \nvisited during the zigzag traversal.\n\n*/\n","compare_result":"111111111111111111111111111111111","title_slug":"binary-tree-zigzag-level-order-traversal","has_notes":false,"flag_type":1}