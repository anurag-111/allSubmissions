{"id":938223605,"lang":"cpp","lang_name":"C++","time":"5Â months","timestamp":1682221978,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/938223605/","is_pending":"Not Pending","title":"Sliding Subarray Beauty","memory":"N/A","code":"class Solution {\npublic:\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\n        vector<int> result;\n        priority_queue<int> pq; // Max heap (priority queue) to store negative integers\n        int negCount = 0; // Count of negative integers in current subarray\n\n        // Iterate through nums from left to right\n        for (int i = 0; i < nums.size(); ++i) {\n            // If current element is within first k elements and negative, push onto pq and increment negCount\n            if (i < k && nums[i] < 0) {\n                pq.push(nums[i]);\n                ++negCount;\n            }\n            // If current element is beyond first k elements\n            else if (i >= k) {\n                // Check if there are any negative integers in pq, and pop elements until we have found x smallest negative integers\n                while (!pq.empty() && negCount > x) {\n                    pq.pop();\n                    --negCount;\n                }\n\n                // Calculate beauty of subarray based on remaining count of negative integers in pq\n                if (!pq.empty()) {\n                    // If there are remaining negative integers in pq, push top element (maximum negative integer) onto result\n                    result.push_back(pq.top());\n                }\n                else {\n                    // Otherwise, push 0 onto result\n                    result.push_back(0);\n                }\n\n                // Remove element that is no longer part of subarray from pq if it is negative\n                if (!pq.empty() && pq.top() == nums[i - k]) {\n                    pq.pop();\n                    --negCount;\n                }\n\n                // Add new element to subarray in pq if it is negative\n                if (nums[i] < 0) {\n                    pq.push(nums[i]);\n                    ++negCount;\n                }\n            }\n        }\n\n        // Process remaining negative integers in pq for last subarray\n        while (!pq.empty() && negCount > x) {\n            pq.pop();\n            --negCount;\n        }\n\n        // Calculate beauty of last subarray based on remaining count of negative integers in pq\n        if (!pq.empty()) {\n            // If there are remaining negative integers in pq, push top element (maximum negative integer) onto result\n            result.push_back(pq.top());\n        }\n        else {\n            // Otherwise, push 0 onto result\n            result.push_back(0);\n        }\n\n        return result;\n    }\n\n\n};\n\n","compare_result":"111111111111111111111111110111101111011111111111111111011011000111111011100111101111101000010101000001111011110000101000111111101001100111001010011111111001100101101100110001001011100000001000011111000000000000101000001000100010001101000011010100000011000000010000000000000111000110001100101000010000000000111100000000001000001011100001101000000000001100010000001100011000000001000110000000001110100000000000010110000001000001000100011010001010001000000010000000000100000000000001100010000100010100000010000000010000000010100000000100001001000010000000000000010000000001000000000000000001000010000000000000000000000000001000110000000000000000000000000000100000000000100000000010000000000000000000000000010100000000011","title_slug":"sliding-subarray-beauty","has_notes":false,"flag_type":1}