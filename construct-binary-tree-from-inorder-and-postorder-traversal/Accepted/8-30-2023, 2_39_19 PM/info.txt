{"id":1035817709,"lang":"cpp","lang_name":"C++","time":"3 weeks, 1 day","timestamp":1693386559,"status":10,"status_display":"Accepted","runtime":"21 ms","url":"/submissions/detail/1035817709/","is_pending":"Not Pending","title":"Construct Binary Tree from Inorder and Postorder Traversal","memory":"26.5 MB","code":"class Solution {\nprivate: \n    TreeNode* buildSubTree(vector<int> &inorder, vector<int> &postorder,int &postIndex, int left, int right, unordered_map<int, int> &inMap) {\n        if(left > right) {\n            return NULL;\n        }\n        \n        int inPivotIndex = inMap[postorder[postIndex--]];\n        TreeNode* node = new TreeNode(inorder[inPivotIndex]);\n        \n        node -> right = buildSubTree(inorder, postorder, postIndex, inPivotIndex + 1, right, inMap);\n        node -> left = buildSubTree(inorder, postorder, postIndex, left, inPivotIndex - 1, inMap);\n        \n        return node;\n    }\n    \npublic:\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        int postIndex = postorder.size() - 1;\n        \n        unordered_map<int, int> inMap;\n        for(int i = 0; i < inorder.size(); i++) {\n            inMap[inorder[i]] = i;\n        }\n        \n        return buildSubTree(inorder, postorder, postIndex, 0, inorder.size() - 1, inMap);      \n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"construct-binary-tree-from-inorder-and-postorder-traversal","has_notes":false,"flag_type":1}