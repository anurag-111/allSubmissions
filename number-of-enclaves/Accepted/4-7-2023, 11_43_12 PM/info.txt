{"id":929765257,"lang":"cpp","lang_name":"C++","time":"5 months, 2 weeks","timestamp":1680891192,"status":10,"status_display":"Accepted","runtime":"79 ms","url":"/submissions/detail/929765257/","is_pending":"Not Pending","title":"Number of Enclaves","memory":"27.6 MB","code":"class Solution {\npublic:\n    int numEnclaves(vector<vector<int>>& grid) {\n        queue<pair<int, int>> enclaves;\n        int grid_row = grid.size();\n        int grid_col = grid[0].size();\n        vector<vector<int>> visited(grid_row, vector<int> (grid_col, 0));\n    \n         \n        // Traversal for the boundaries 1's\n        for(int i = 0; i < grid_row; i++) {\n            for(int j =0; j < grid_col; j++) {\n                if(i == 0 || j == 0 || i == grid_row - 1 || j == grid_col - 1) {\n                     if(grid[i][j] == 1) {\n                         // Inserting the index of the 1 found\n                         enclaves.push({i, j});\n\n                         // Marking the 1 found in the visited array\n                         visited[i][j] = 1;     \n                     }\n                }\n            }\n        }\n\n        int dir_row[] = {-1, 0, +1, 0};\n        int dir_col[] = {0, +1, 0, -1};\n\n        while(!enclaves.empty()) {\n            int row = enclaves.front().first;\n            int col = enclaves.front().second;\n            enclaves.pop();\n\n            // Traversal in all the 4 directions\n            for(int i = 0; i < 4; i++) {\n                int nrow = row + dir_row[i];\n                int ncol = col + dir_col[i];\n\n                // Check for valid coordinates and for land cell\n                if(nrow >= 0 && nrow < grid_row && ncol >= 0 && ncol < grid_col && \n                    visited[nrow][ncol] == 0 && grid[nrow][ncol] == 1) {\n                            enclaves.push({nrow, ncol});\n                            visited[nrow][ncol] = 1;\n                }\n            }\n        }\n\n        // Check for the number of land cells in grid for which we cannot walk off the \n        // boundary of the grid in any number of moves.\n        int count = 0;\n        for(int i = 0; i < grid_row; i++) {\n            for(int j = 0; j < grid_col; j++) {\n                // Check for unvisited land cell\n                if(grid[i][j] == 1 && visited[i][j] == 0) {\n                    count++;\n                }\n            }\n        }\n\n        return count;\n    }\n};\n\n\n// Time Complexity: O(N x M x 4) ~ O(N x M) :\n\n//     For the worst case, assuming all the pieces as land, the BFS function will be called for (N x M) nodes \n//     and for every node, we are traversing for 4 neighbors, so it will take O(N x M x 4) time. \n\n// Space Complexity ~ O(N x M) :\n\n//     O(N x M) for the visited array, and queue space takes up N x M locations at max. ","compare_result":"1111111111111111111111111111111111111111111111111111111111","title_slug":"number-of-enclaves","has_notes":false,"flag_type":1}