{"id":941657655,"lang":"cpp","lang_name":"C++","time":"4 months, 3 weeks","timestamp":1682784563,"status":10,"status_display":"Accepted","runtime":"782 ms","url":"/submissions/detail/941657655/","is_pending":"Not Pending","title":"Make Array Empty","memory":"189.3 MB","code":"class Solution {\npublic:\n    long long countOperationsToEmptyArray(vector<int>& nums) {\n        // Map to store the indices of each number in the array\n        map<int, set<int>> indexMap;\n\n        // Initialize the map\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            indexMap[nums[i]].insert(i);\n        }\n\n        // Variable to store the number of operations needed to empty the array\n        long long operations = 0;\n\n        // Keep looping until the array is empty\n        while (n > 0) {\n            // Start a new subarray with the smallest value in the map\n            int subarrayLength = 1;\n            int currentValue = indexMap.begin()->first;\n            int currentIndex = *indexMap.begin()->second.begin();\n\n            // Remove the current index from the map\n            indexMap[currentValue].erase(currentIndex);\n            if (indexMap[currentValue].empty()) {\n                indexMap.erase(currentValue);\n            }\n\n            // Keep adding elements to the subarray as long as they form a non-decreasing sequence\n            while (!indexMap.empty()) {\n                subarrayLength++;\n\n                // If the current value is in the map and there is an index greater than the current index,\n                // add that index to the subarray\n                if (indexMap.find(currentValue) != indexMap.end() && *indexMap[currentValue].rbegin() > currentIndex) {\n                    currentIndex = *indexMap[currentValue].upper_bound(currentIndex);\n                    indexMap[currentValue].erase(currentIndex);\n                    if (indexMap[currentValue].empty()) {\n                        indexMap.erase(currentValue);\n                    }\n                }\n                // If there is a smaller value in the map, add the index of the largest element in that set to the subarray\n                else if (indexMap.begin()->first > currentValue && *indexMap.begin()->second.rbegin() > currentIndex) {\n                    currentValue = indexMap.begin()->first;\n                    currentIndex = *indexMap[currentValue].upper_bound(currentIndex);\n                    indexMap[currentValue].erase(currentIndex);\n                    if (indexMap[currentValue].empty()) {\n                        indexMap.erase(currentValue);\n                    }\n                }\n                // If neither condition is met, the current subarray is complete\n                else {\n                    subarrayLength--;\n                    break;\n                }\n            }\n\n            // Add the number of operations needed to empty the current subarray to the total operations count\n            operations += n;\n            n -= subarrayLength;\n        }\n        return operations;\n    }\n};\n","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"make-array-empty","has_notes":false,"flag_type":1}