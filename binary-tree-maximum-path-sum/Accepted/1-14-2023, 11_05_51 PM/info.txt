{"id":878131260,"lang":"cpp","lang_name":"C++","time":"8 months, 1 week","timestamp":1673717751,"status":10,"status_display":"Accepted","runtime":"19 ms","url":"/submissions/detail/878131260/","is_pending":"Not Pending","title":"Binary Tree Maximum Path Sum","memory":"28.3 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    int maxpathsum_util(TreeNode* root, int &result) {\n        if (!root) {\n            return 0;\n        }\n        \n        int left = maxpathsum_util (root->left, result);\n        int right = maxpathsum_util (root->right, result);\n        \n        int max_straight = max(max(left,right) + root -> val, root -> val);\n        int max_case_val = max(max_straight, left + right + root -> val);\n        result = max(max_case_val, result);\n        \n        return max_straight;\n    }\n    \npublic:\n    int maxPathSum(TreeNode* root) {\n        int result = INT_MIN;\n        maxpathsum_util(root, result);\n        return result;\n    }\n};\n\n/*\n  CASE 1 : current node is in the path of max sum\n  \n       1\n      / \\\n     2   3\n    / \\\n   2   1  \n  \n  ms = max (max(left, right) + root->val, root->val)\n  \n  CASE 2 : current node is the root of max sum path\n  \n       1\n      / \\\n     2   2\n    / \\\n   8   8\n  /\n-2\n\n m21 = max (ins, left + right + root->val)\n \n CASE 3 : current node is not in path of the sum\n \n       1\n      / \\\n     2   2\n    / \n   8   \n  / \\\n100 100\n \n result = max(m21, result)\n\n*/","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"binary-tree-maximum-path-sum","has_notes":false,"flag_type":1}