{"id":1037131239,"lang":"cpp","lang_name":"C++","time":"2 weeks, 6 days","timestamp":1693513332,"status":10,"status_display":"Accepted","runtime":"20 ms","url":"/submissions/detail/1037131239/","is_pending":"Not Pending","title":"Binary Tree Maximum Path Sum","memory":"28.1 MB","code":"class Solution {\n    private:\n        int solve(TreeNode *root, int &maxPathSum) {\n            if(root == NULL) {\n                return 0;\n            }\n\n            int left = solve(root -> left, maxPathSum);\n            int right = solve(root -> right, maxPathSum); \n\n            int maxLeftOrRight = max(left, right);\n\n            // Handles the cases : root + max(left, right) OR only the root\n            // should be returned from the current node\n            int maxToReturn = max(root-> val + maxLeftOrRight, root->val);\n\n            // Handles the case when the current traversed path is itself\n            // the max path otheriwse update with the maximum path.\n            int currentPathSum = max(root->val + left + right, maxToReturn);\n\n            // Update the result\n            maxPathSum = max(maxPathSum, currentPathSum);\n\n            return maxToReturn;            \n        }\n        \n    public:\n        int maxPathSum(TreeNode* root) {\n            int maxPathSum = root->val;\n            solve(root, maxPathSum);\n            return maxPathSum;\n        }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"binary-tree-maximum-path-sum","has_notes":false,"flag_type":1}