{"id":1022577787,"lang":"cpp","lang_name":"C++","time":"1Â month","timestamp":1692151196,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1022577787/","is_pending":"Not Pending","title":"All Nodes Distance K in Binary Tree","memory":"N/A","code":"class Solution {\nprivate:\n    void markParent(TreeNode* root, unordered_map<TreeNode*, TreeNode*> &parentTrack, TreeNode* target) {\n        // Mapping : node -> parent\n\n        // Queue for storage\n        queue<TreeNode*> nodes;\n        nodes.push(root);\n\n        // Traversal over the tree\n        while(!nodes.empty()) {\n            TreeNode* current = nodes.front();\n            nodes.pop();\n\n            // Check for left node\n            if(current -> left) {\n                nodes.push(current -> left);\n                parentTrack[current -> left] = current;\n            }\n\n            // Check for the right node\n            if(current -> right) {\n                nodes.push(current -> right);\n                parentTrack[current -> right] = current;\n            }\n        }\n    }\npublic:\n    vector<int> distanceK(TreeNode* root, TreeNode* target, int k) {\n        // Mapping of child -> node\n        unordered_map<TreeNode*, TreeNode*> parentTrack;\n\n        // Function call for parent mapping\n        markParent(root, parentTrack, target);\n\n        // Queue for traversal storage\n        queue<TreeNode*> nodes;\n        nodes.push(root);\n\n        // Visited mapping\n        unordered_map<TreeNode*, bool> visited;\n\n        // Current level indicator\n        int currentLevel = 0;\n\n        while(!nodes.empty()) {\n            // Size of the current tree level\n            int size = nodes.size();\n\n            if(currentLevel == k) {\n                break;\n            }\n\n            currentLevel++;\n\n            // Traversing through the level\n            for(int i = 0; i < size; i++) {\n                TreeNode* current = nodes.front();\n                nodes.pop();\n\n                if(current -> left != NULL && !visited[current -> left]) {\n                    nodes.push(current -> left);\n                    visited[current -> left] = true;\n                }\n\n                if(current -> right != NULL && !visited[current -> right]) {\n                    nodes.push(current -> right);\n                    visited[current -> right] = true;\n                }\n\n                if(parentTrack[current] != NULL && !visited[parentTrack[current]]) {\n                    nodes.push(parentTrack[current]);\n                    visited[parentTrack[current]] = true;\n                }\n            }\n        }\n\n        vector<int> result;\n        while(!nodes.empty()) {\n            TreeNode *current = nodes.front();\n            nodes.pop();\n            result.push_back(current -> val);\n        }\n\n        return result;\n\n    }\n};","compare_result":"010010000000000000000000000000000000010100100100110101100","title_slug":"all-nodes-distance-k-in-binary-tree","has_notes":false,"flag_type":1}