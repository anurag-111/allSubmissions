{"id":1022578428,"lang":"cpp","lang_name":"C++","time":"1Â month","timestamp":1692151283,"status":10,"status_display":"Accepted","runtime":"9 ms","url":"/submissions/detail/1022578428/","is_pending":"Not Pending","title":"All Nodes Distance K in Binary Tree","memory":"12.9 MB","code":"class Solution {\nprivate:\n    void markParent(TreeNode* root, unordered_map<TreeNode*, TreeNode*>& parentTrack, TreeNode* target) {\n        // Mapping: node -> parent\n\n        // Queue for storage\n        queue<TreeNode*> nodes;\n        nodes.push(root);\n\n        // Traversal over the tree\n        while (!nodes.empty()) {\n            TreeNode* current = nodes.front();\n            nodes.pop();\n\n            // Check for left node\n            if (current->left) {\n                nodes.push(current->left);\n                parentTrack[current->left] = current;\n            }\n\n            // Check for the right node\n            if (current->right) {\n                nodes.push(current->right);\n                parentTrack[current->right] = current;\n            }\n        }\n    }\n\npublic:\n    vector<int> distanceK(TreeNode* root, TreeNode* target, int k) {\n        // Mapping of child -> parent\n        unordered_map<TreeNode*, TreeNode*> parentTrack;\n\n        // Function call for parent mapping\n        markParent(root, parentTrack, target);\n\n        // Queue for traversal storage\n        queue<TreeNode*> nodes;\n        nodes.push(target);  // Start from the target node\n\n        int currentLevel = 0;\n\n        // Set to track visited nodes\n        unordered_set<TreeNode*> visited;\n        visited.insert(target);  // Mark the target node as visited\n\n        // Traverse through the levels\n        while (!nodes.empty()) {\n            int size = nodes.size();\n\n            if (currentLevel == k) {\n                break;  // Reached the desired distance\n            }\n\n            // Traversing through the level\n            for (int i = 0; i < size; i++) {\n                TreeNode* current = nodes.front();\n                nodes.pop();\n\n                if (current->left && visited.find(current->left) == visited.end()) {\n                    nodes.push(current->left);\n                    visited.insert(current->left);\n                }\n\n                if (current->right && visited.find(current->right) == visited.end()) {\n                    nodes.push(current->right);\n                    visited.insert(current->right);\n                }\n\n                if (parentTrack[current] && visited.find(parentTrack[current]) == visited.end()) {\n                    nodes.push(parentTrack[current]);\n                    visited.insert(parentTrack[current]);\n                }\n            }\n\n            currentLevel++;  // Increment the level here\n        }\n\n        // Extract nodes at the required distance from the target\n        vector<int> result;\n        while (!nodes.empty()) {\n            TreeNode* current = nodes.front();\n            nodes.pop();\n            result.push_back(current->val);\n        }\n\n        return result;\n    }\n};\n\n\n// Time Complexity: O(N + k)\n// Space Complexity: O(N)\n// Where N is the number of nodes in the binary tree and k is the distance you're searching for.","compare_result":"111111111111111111111111111111111111111111111111111111111","title_slug":"all-nodes-distance-k-in-binary-tree","has_notes":false,"flag_type":1}