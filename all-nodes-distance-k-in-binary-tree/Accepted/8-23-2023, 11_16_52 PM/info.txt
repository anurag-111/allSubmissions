{"id":1029797232,"lang":"cpp","lang_name":"C++","time":"4Â weeks","timestamp":1692812812,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1029797232/","is_pending":"Not Pending","title":"All Nodes Distance K in Binary Tree","memory":"13.1 MB","code":"class Solution {\nprivate:\n\tvoid childParentMapper(TreeNode *root, unordered_map<TreeNode *, TreeNode*> &childParentMap, TreeNode *target) {\n\t\t// Node storage\n\t\tqueue<TreeNode*> nodes;\n\t\tnodes.push(root);\n\t\t\n\t\twhile(!nodes.empty()) {\n\t\t\tint size = nodes.size();\n\t\t\t\n\t\t\tfor(int i = 0; i < size; i++) {\n\t\t\t\tTreeNode *current = nodes.front();\n\t\t\t\tnodes.pop();\n\t\t\t\t\n\t\t\t\tif(current -> left) {\n\t\t\t\t\tnodes.push(current -> left);\n\t\t\t\t\tchildParentMap[current -> left] = current;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(current -> right) {\n\t\t\t\t\tnodes.push(current -> right);\n\t\t\t\t\tchildParentMap[current -> right] = current;\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\npublic:\n    vector<int> distanceK(TreeNode* root, TreeNode* target, int k) {\n        // For mapping\n\t\tunordered_map<TreeNode*, TreeNode*> childParentMap;\n\t\t\n\t\t// Function for mapping\n\t\tchildParentMapper(root, childParentMap, target);\n\t\t\n\t\t// Node storage\n\t\tqueue<TreeNode*> nodes;\n\t\tnodes.push(target);\n\t\t\n\t\t// Level indicator\n\t\tint currentLevel = 0;\n\t\t\n\t\t// Visited mapping\n\t\tunordered_set<TreeNode*> visited;\n\t\tvisited.insert(target);\n\t\t\n\t\twhile(!nodes.empty()) {\n\t\t\tint size = nodes.size();\n\t\t\t\n\t\t\t// Current level check\n\t\t\tif(currentLevel == k) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t//  Traversing over the loop\n\t\t\tfor(int i = 0; i < size; i++) {\n\t\t\t\t// Extraction of nodes\n\t\t\t\tTreeNode *current = nodes.front();\n\t\t\t\tnodes.pop();\n\t\t\t\t\n\t\t\t\t// Left traversal nodes\n\t\t\t\tif(current -> left && visited.find(current -> left) == visited.end()) {\n\t\t\t\t\tnodes.push(current -> left);\n\t\t\t\t\tvisited.insert(current -> left);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Right traversal nodes\n\t\t\t\tif(current -> right && visited.find(current -> right) == visited.end()) {\n\t\t\t\t\tnodes.push(current -> right);\n\t\t\t\t\tvisited.insert(current -> right);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Parent node\n\t\t\t\tif(childParentMap[current] && visited.find(childParentMap[current]) == visited.end()) {\n\t\t\t\t\tnodes.push(childParentMap[current]);\n\t\t\t\t\tvisited.insert(childParentMap[current]);\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// Update the current level\n\t\t\tcurrentLevel++;\n\t\t}\n\t\t\n\t\t// For storing the resultant node's value\n\t\tvector<int> result;\n\t\t\n\t\t// Pop the required nodes\n\t\twhile(!nodes.empty()) {\n\t\t\tTreeNode *current = nodes.front();\n\t\t\tnodes.pop();\n\t\t\t// Add the nodes\n\t\t\tresult.push_back(current -> val);\n\t\t}\n\t\t\n\t\treturn result;\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111","title_slug":"all-nodes-distance-k-in-binary-tree","has_notes":false,"flag_type":1}