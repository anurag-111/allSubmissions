{"id":896485880,"lang":"cpp","lang_name":"C++","time":"7 months, 1 week","timestamp":1676197769,"status":10,"status_display":"Accepted","runtime":"615 ms","url":"/submissions/detail/896485880/","is_pending":"Not Pending","title":"Minimum Fuel Cost to Report to the Capital","memory":"170.8 MB","code":"class Solution {\npublic:\n    long long fuel = 0;\n\n    long long dfs(vector<vector<int>>& adj_list, int node,vector<int>& visited, int& seats) {\n        visited[node] = true;\n\n        long long count = 1;   //count of nodes\n        \n        for(int i = 0; i < adj_list[node].size(); i++) {\n            int current = adj_list[node][i];\n\n            if(!visited[current]) {\n                // Add count of representatives in each child subtree \n                // to the parent subtree.\n                count += dfs(adj_list, current, visited, seats);\n            }\n        }\n\n        long long car_count = count / seats;\n\n        if(count % seats != 0) {                   \n            car_count++;\n        }\n\n        if(node != 0) {\n            // Count the fuel it takes to move to the parent node.\n            // Root node does not have any parent so we ignore it\n            fuel += car_count;\n        }\n\n        return count;\n\n    }\n\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\n        \n        if(roads.size() == 0) {\n            return 0;\n        }\n        \n        fuel = 0;\n        int n = roads.size();\n        vector<vector<int>> adj_list(n + 1);  \n\n        for (int i = 0; i < n; i++) {\n            int x = roads[i][0];\n            int y = roads[i][1];\n            adj_list[x].push_back(y);\n            adj_list[y].push_back(x);\n        }\n        \n        vector<int> visited(n + 1, 0);\n        dfs(adj_list, 0, visited, seats);\n\n        return fuel;\n    }\n};\n\n\n/*\n\n    Complexity Analysis:\n\n    Here n is the number of nodes.\n    ____________________________________________________________________________________________________\n\n    Time complexity: O(n)\n\n    The dfs function visits each node once, which takes O(n) time in total. \n    Because we have n - 1 undirected edges, each edge can only be iterated twice (by nodes at the end), \n    resulting in O(n) operations total while visiting all nodes.\n    We also need O(n) time to initialize the adjacency list.\n\n    ____________________________________________________________________________________________________\n    \n    Space complexity: O(n)\n\n    Building the adjacency list takes O(n) space.\n    The recursion call stack used by dfs can have no more than nnn elements in the worst-case scenario. \n    It would take up O(n) space in that case.\n\n*/","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"minimum-fuel-cost-to-report-to-the-capital","has_notes":false,"flag_type":1}