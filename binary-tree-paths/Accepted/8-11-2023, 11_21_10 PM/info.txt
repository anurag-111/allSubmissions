{"id":1018642279,"lang":"cpp","lang_name":"C++","time":"1 month, 1 week","timestamp":1691776270,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1018642279/","is_pending":"Not Pending","title":"Binary Tree Paths","memory":"15.6 MB","code":"class Solution {\nprivate:\n    // Recursive function to find all paths from the root to leaf nodes\n    vector<string> paths(TreeNode* root, vector<string>& result, string str) {\n        // If the current node is a leaf node, add the current path to the result\n        if (root->left == NULL && root->right == NULL) {\n            result.push_back(str);\n        }\n\n        // If the left child exists, recursively explore the left subtree\n        if (root->left) {\n            paths(root->left, result, str + \"->\" + to_string(root->left->val));\n        }\n\n        // If the right child exists, recursively explore the right subtree\n        if (root->right) {\n            paths(root->right, result, str + \"->\" + to_string(root->right->val));\n        }\n\n        return result;\n    }\n\npublic:\n    // Function to find all root-to-leaf paths in a binary tree\n    vector<string> binaryTreePaths(TreeNode* root) {\n        vector<string> result;\n\n        // If the tree is empty, return an empty result\n        if (root == NULL) {\n            return result;\n        }\n\n        // Start the path with the root value and explore all possible paths\n        return paths(root, result, to_string(root->val));\n    }\n};\n","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"binary-tree-paths","has_notes":false,"flag_type":1}