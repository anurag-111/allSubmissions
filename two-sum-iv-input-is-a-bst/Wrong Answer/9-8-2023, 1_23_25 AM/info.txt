{"id":1043347958,"lang":"cpp","lang_name":"C++","time":"1 week, 6 days","timestamp":1694116405,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1043347958/","is_pending":"Not Pending","title":"Two Sum IV - Input is a BST","memory":"N/A","code":"// val, left, right\nclass Solution {\nprivate:\n    void calculateInorder(TreeNode *root, vector<int> &inorderTraversal) {\n        if(root == NULL) {\n            return;\n        }\n\n        calculateInorder(root -> left, inorderTraversal);\n        inorderTraversal.push_back(root -> val);\n        calculateInorder(root -> right, inorderTraversal);\n    }\npublic:\n    bool findTarget(TreeNode *root, int k) {\n        // 1. Find the inorder traversal of the tree\n        vector<int> inorderTraversal;\n        calculateInorder(root, inorderTraversal);\n\n        // for(int num : inorderTraversal) {\n        //     cout << num << \" \";\n        // }\n\n        // 2. Apply two pointer approach\n        int i = 0;\n        int j = inorderTraversal.size() - 1;\n        while(i <= j) {\n            int sum = inorderTraversal[i] + inorderTraversal[j];\n            if(sum == k) {\n                return true;\n            } else if(sum > k) {\n                j--;\n            } else {\n                i++;\n            }\n        }\n\n        return false;\n    }\n};","compare_result":"111111011111111111111111111011101111101111111011111111011011111111110011111010111111111111111111111111111111111111111111111111111111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111101111111111111111111111111111111111111011111111111111111110","title_slug":"two-sum-iv-input-is-a-bst","has_notes":false,"flag_type":1}