{"id":1043349776,"lang":"cpp","lang_name":"C++","time":"1 week, 6 days","timestamp":1694116572,"status":10,"status_display":"Accepted","runtime":"31 ms","url":"/submissions/detail/1043349776/","is_pending":"Not Pending","title":"Two Sum IV - Input is a BST","memory":"36.9 MB","code":"// val, left, right\nclass Solution {\nprivate:\n    void calculateInorder(TreeNode *root, vector<int> &inorderTraversal) {\n        if(root == NULL) {\n            return;\n        }\n\n        calculateInorder(root -> left, inorderTraversal);\n        inorderTraversal.push_back(root -> val);\n        calculateInorder(root -> right, inorderTraversal);\n    }\npublic:\n    bool findTarget(TreeNode *root, int k) {\n        // 1. Find the inorder traversal of the tree\n        vector<int> inorderTraversal;\n        calculateInorder(root, inorderTraversal);\n\n        for(int num : inorderTraversal) {\n            cout << num << \" \";\n        }\n\n        int flag = 0;\n        // 2. Apply two pointer approach\n        int i = 0;\n        int j = inorderTraversal.size() - 1;\n        while(i < j) {\n            int sum = inorderTraversal[i] + inorderTraversal[j];\n            if(sum == k) {\n                flag = 1;\n                break;\n            } else if(sum > k) {\n                j--;\n            } else {\n                i++;\n            }\n        }\n\n        if(flag) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"two-sum-iv-input-is-a-bst","has_notes":false,"flag_type":1}