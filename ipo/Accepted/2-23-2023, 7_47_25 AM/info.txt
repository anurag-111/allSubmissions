{"id":903246563,"lang":"java","lang_name":"Java","time":"7Â months","timestamp":1677118645,"status":10,"status_display":"Accepted","runtime":"125 ms","url":"/submissions/detail/903246563/","is_pending":"Not Pending","title":"IPO","memory":"88.8 MB","code":"class Solution {\n    public int findMaximizedCapital(int k, int W, int[] Profits, int[] Capital) {\n        \n        PriorityQueue<int[]> minCapitalProjects = new PriorityQueue<>((a,b) -> a[0] - b[0]);\n        PriorityQueue<Integer> maxProfits = new PriorityQueue<>((a,b) -> b - a);\n        \n\t\t// Building the minHeap pair of capital and profits, sorted in ascending order of capital        \n        for(int i=0; i<Capital.length; i++) {\n            minCapitalProjects.add(new int[]{Capital[i], Profits[i]});\n        }\n            \n        \n        // Check until k projects are completed\n        for (int i=0; i < k; i++){\n            \n            // Pick up all projects that meets current cummulative capital and store it in a maxHeap of profits\n            while(!minCapitalProjects.isEmpty() && minCapitalProjects.peek()[0] <= W) {\n                maxProfits.add(minCapitalProjects.poll()[1]);\n            }\n                \n            if(maxProfits.isEmpty()) \n                return W;\n\n            // Update the capital by polling the highest profit element from the maxHeap of profits\n            W += maxProfits.poll();\n        }\n        return W;\n    }\n}","compare_result":"11111111111111111111111111111111111","title_slug":"ipo","has_notes":false,"flag_type":1}